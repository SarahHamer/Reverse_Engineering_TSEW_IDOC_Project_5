# Disassembly for typing.runtime_checkable
# From module file: typing

## co_consts:
("Mark a protocol class as a runtime protocol.\n\n    Such protocol can be used with isinstance() and issubclass().\n    Raise TypeError if applied to a non-protocol class.\n    This allows a simple-minded structural check very similar to\n    one trick ponies in collections.abc such as Iterable.\n\n    For example::\n\n        @runtime_checkable\n        class Closable(Protocol):\n            def close(self): ...\n\n        assert isinstance(open('/some/file'), Closable)\n\n    Warning: this will check only the presence of the required methods,\n    not their type signatures!\n    ", '@runtime_checkable can be only applied to protocol classes, got %r', True)

## co_names:
('issubclass', 'Generic', '_is_protocol', 'TypeError', '_is_runtime_protocol')

## bytecode:

   0: RESUME               
   2: LOAD_GLOBAL          NULL + issubclass
  14: LOAD_FAST            cls
  16: LOAD_GLOBAL          Generic
  28: PRECALL              
  32: CALL                 
  42: POP_JUMP_FORWARD_IF_FALSE to 58
  44: LOAD_FAST            cls
  46: LOAD_ATTR            _is_protocol
  56: POP_JUMP_FORWARD_IF_TRUE to 94
  58: LOAD_GLOBAL          NULL + TypeError
  70: LOAD_CONST           '@runtime_checkable can be only applied to protocol classes, got %r'
  72: LOAD_FAST            cls
  74: BINARY_OP            %
  78: PRECALL              
  82: CALL                 
  92: RAISE_VARARGS        
  94: LOAD_CONST           True
  96: LOAD_FAST            cls
  98: STORE_ATTR           _is_runtime_protocol
 108: LOAD_FAST            cls
 110: RETURN_VALUE         
