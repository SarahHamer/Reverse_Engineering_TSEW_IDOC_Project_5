# Disassembly for typing.Protocol
# From module file: typing

## co_consts:
('Protocol', 'Base class for protocol classes.\n\n    Protocol classes are defined as::\n\n        class Proto(Protocol):\n            def meth(self) -> int:\n                ...\n\n    Such classes are primarily used with static type checkers that recognize\n    structural subtyping (static duck-typing).\n\n    For example::\n\n        class C:\n            def meth(self) -> int:\n                return 0\n\n        def func(x: Proto) -> int:\n            return x.meth()\n\n        func(C())  # Passes static type check\n\n    See PEP 544 for details. Protocol classes decorated with\n    @typing.runtime_checkable act as simple-minded runtime protocols that check\n    only the presence of given attributes, ignoring their type signatures.\n    Protocol classes can be generic, they are defined as::\n\n        class GenProto(Protocol[T]):\n            def meth(self) -> T:\n                ...\n    ', (), True, False, <code object __init_subclass__ at 0x0000024068C0B800, file "typing.py", line 2045>)

## co_names:
('__name__', '__module__', '__qualname__', '__doc__', '__slots__', '_is_protocol', '_is_runtime_protocol', '__init_subclass__', '__classcell__')

## bytecode:

   0: MAKE_CELL            __class__
   2: RESUME               
   4: LOAD_NAME            __name__
   6: STORE_NAME           __module__
   8: LOAD_CONST           'Protocol'
  10: STORE_NAME           __qualname__
  12: LOAD_CONST           'Base class for protocol classes.\n\n    Protocol classes are defined as::\n\n        class Proto(Protocol):\n            def meth(self) -> int:\n                ...\n\n    Such classes are primarily used with static type checkers that recognize\n    structural subtyping (static duck-typing).\n\n    For example::\n\n        class C:\n            def meth(self) -> int:\n                return 0\n\n        def func(x: Proto) -> int:\n            return x.meth()\n\n        func(C())  # Passes static type check\n\n    See PEP 544 for details. Protocol classes decorated with\n    @typing.runtime_checkable act as simple-minded runtime protocols that check\n    only the presence of given attributes, ignoring their type signatures.\n    Protocol classes can be generic, they are defined as::\n\n        class GenProto(Protocol[T]):\n            def meth(self) -> T:\n                ...\n    '
  14: STORE_NAME           __doc__
  16: LOAD_CONST           ()
  18: STORE_NAME           __slots__
  20: LOAD_CONST           True
  22: STORE_NAME           _is_protocol
  24: LOAD_CONST           False
  26: STORE_NAME           _is_runtime_protocol
  28: LOAD_CLOSURE         __class__
  30: BUILD_TUPLE          
  32: LOAD_CONST           <code object __init_subclass__ at 0x0000024068C0B800, file "typing.py", line 2045>
  34: MAKE_FUNCTION        closure
  36: STORE_NAME           __init_subclass__
  38: LOAD_CLOSURE         __class__
  40: COPY                 
  42: STORE_NAME           __classcell__
  44: RETURN_VALUE         
