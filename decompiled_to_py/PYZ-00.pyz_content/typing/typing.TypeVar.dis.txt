# Disassembly for typing.TypeVar
# From module file: typing

## co_consts:
('TypeVar', "Type variable.\n\n    Usage::\n\n      T = TypeVar('T')  # Can be anything\n      A = TypeVar('A', str, bytes)  # Must be str or bytes\n\n    Type variables exist primarily for the benefit of static type\n    checkers.  They serve as the parameters for generic types as well\n    as for generic function definitions.  See class Generic for more\n    information on generic types.  Generic functions work as follows:\n\n      def repeat(x: T, n: int) -> List[T]:\n          '''Return a list containing n references to x.'''\n          return [x]*n\n\n      def longest(x: A, y: A) -> A:\n          '''Return the longest of two strings.'''\n          return x if len(x) >= len(y) else y\n\n    The latter example's signature is essentially the overloading\n    of (str, str) -> str and (bytes, bytes) -> bytes.  Also note\n    that if the arguments are instances of some subclass of str,\n    the return type is still plain str.\n\n    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\n    Type variables defined with covariant=True or contravariant=True\n    can be used to declare covariant or contravariant generic types.\n    See PEP 484 for more details. By default generic types are invariant\n    in all type variables.\n\n    Type variables can be introspected. e.g.:\n\n      T.__name__ == 'T'\n      T.__constraints__ == ()\n      T.__covariant__ == False\n      T.__contravariant__ = False\n      A.__constraints__ == (str, bytes)\n\n    Note that only type variables defined in global scope can be pickled.\n    ", None, False, ('bound', 'covariant', 'contravariant'), <code object __init__ at 0x0000024068BF6C60, file "typing.py", line 1019>, <code object __typing_subst__ at 0x00000240691F5BD0, file "typing.py", line 1033>)

## co_names:
('__name__', '__module__', '__qualname__', '__doc__', '__init__', '__typing_subst__', '__classcell__')

## bytecode:

   0: MAKE_CELL            __class__
   2: RESUME               
   4: LOAD_NAME            __name__
   6: STORE_NAME           __module__
   8: LOAD_CONST           'TypeVar'
  10: STORE_NAME           __qualname__
  12: LOAD_CONST           "Type variable.\n\n    Usage::\n\n      T = TypeVar('T')  # Can be anything\n      A = TypeVar('A', str, bytes)  # Must be str or bytes\n\n    Type variables exist primarily for the benefit of static type\n    checkers.  They serve as the parameters for generic types as well\n    as for generic function definitions.  See class Generic for more\n    information on generic types.  Generic functions work as follows:\n\n      def repeat(x: T, n: int) -> List[T]:\n          '''Return a list containing n references to x.'''\n          return [x]*n\n\n      def longest(x: A, y: A) -> A:\n          '''Return the longest of two strings.'''\n          return x if len(x) >= len(y) else y\n\n    The latter example's signature is essentially the overloading\n    of (str, str) -> str and (bytes, bytes) -> bytes.  Also note\n    that if the arguments are instances of some subclass of str,\n    the return type is still plain str.\n\n    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\n    Type variables defined with covariant=True or contravariant=True\n    can be used to declare covariant or contravariant generic types.\n    See PEP 484 for more details. By default generic types are invariant\n    in all type variables.\n\n    Type variables can be introspected. e.g.:\n\n      T.__name__ == 'T'\n      T.__constraints__ == ()\n      T.__covariant__ == False\n      T.__contravariant__ = False\n      A.__constraints__ == (str, bytes)\n\n    Note that only type variables defined in global scope can be pickled.\n    "
  14: STORE_NAME           __doc__
  16: LOAD_CONST           None
  18: LOAD_CONST           False
  20: LOAD_CONST           False
  22: LOAD_CONST           ('bound', 'covariant', 'contravariant')
  24: BUILD_CONST_KEY_MAP  
  26: LOAD_CLOSURE         __class__
  28: BUILD_TUPLE          
  30: LOAD_CONST           <code object __init__ at 0x0000024068BF6C60, file "typing.py", line 1019>
  32: MAKE_FUNCTION        kwdefaults, closure
  34: STORE_NAME           __init__
  36: LOAD_CONST           <code object __typing_subst__ at 0x00000240691F5BD0, file "typing.py", line 1033>
  38: MAKE_FUNCTION        
  40: STORE_NAME           __typing_subst__
  42: LOAD_CLOSURE         __class__
  44: COPY                 
  46: STORE_NAME           __classcell__
  48: RETURN_VALUE         
