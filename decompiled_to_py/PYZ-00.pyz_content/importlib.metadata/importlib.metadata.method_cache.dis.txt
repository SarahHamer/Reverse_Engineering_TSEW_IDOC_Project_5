# Disassembly for importlib.metadata.method_cache
# From module file: importlib.metadata._functools

## co_consts:
("\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    ", <code object wrapper at 0x00000240693AB5F0, file "importlib\metadata\_functools.py", line 75>, <code object <lambda> at 0x000002406943B9F0, file "importlib\metadata\_functools.py", line 83>)

## co_names:
('functools', 'lru_cache', 'cache_clear')

## bytecode:

   0: MAKE_CELL            method
   2: MAKE_CELL            cache_wrapper
   4: RESUME               
   6: LOAD_DEREF           cache_wrapper
   8: JUMP_IF_TRUE_OR_POP  to 46
  10: LOAD_GLOBAL          NULL + functools
  22: LOAD_ATTR            lru_cache
  32: PRECALL              
  36: CALL                 
  46: STORE_DEREF          cache_wrapper
  48: LOAD_CLOSURE         cache_wrapper
  50: LOAD_CLOSURE         method
  52: BUILD_TUPLE          
  54: LOAD_CONST           <code object wrapper at 0x00000240693AB5F0, file "importlib\metadata\_functools.py", line 75>
  56: MAKE_FUNCTION        closure
  58: STORE_FAST           wrapper
  60: LOAD_CONST           <code object <lambda> at 0x000002406943B9F0, file "importlib\metadata\_functools.py", line 83>
  62: MAKE_FUNCTION        
  64: LOAD_FAST            wrapper
  66: STORE_ATTR           cache_clear
  76: LOAD_FAST            wrapper
  78: RETURN_VALUE         
