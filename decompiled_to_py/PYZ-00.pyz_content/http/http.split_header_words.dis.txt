# Disassembly for http.split_header_words
# From module file: http.cookiejar

## co_consts:
('Parse header values into a list of lists containing key,value pairs.\n\n    The function knows how to deal with ",", ";" and "=" as well as quoted\n    values after "=".  A list of space separated tokens are parsed as if they\n    were separated by ";".\n\n    If the header_values passed as argument contains multiple values, then they\n    are treated as if they were a single value separated by comma ",".\n\n    This means that this function is useful for parsing header fields that\n    follow this syntax (BNF as from the HTTP/1.1 specification, but we relax\n    the requirement for tokens).\n\n      headers           = #header\n      header            = (token | parameter) *( [";"] (token | parameter))\n\n      token             = 1*<any CHAR except CTLs or separators>\n      separators        = "(" | ")" | "<" | ">" | "@"\n                        | "," | ";" | ":" | "\\" | <">\n                        | "/" | "[" | "]" | "?" | "="\n                        | "{" | "}" | SP | HT\n\n      quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )\n      qdtext            = <any TEXT except <">>\n      quoted-pair       = "\\" CHAR\n\n      parameter         = attribute "=" value\n      attribute         = token\n      value             = token | quoted-string\n\n    Each header is represented by a list of key/value pairs.  The value for a\n    simple token (not part of a parameter) is None.  Syntactically incorrect\n    headers will not necessarily be parsed as you would want.\n\n    This is easier to describe with some examples:\n\n    >>> split_header_words([\'foo="bar"; port="80,81"; discard, bar=baz\'])\n    [[(\'foo\', \'bar\'), (\'port\', \'80,81\'), (\'discard\', None)], [(\'bar\', \'baz\')]]\n    >>> split_header_words([\'text/html; charset="iso-8859-1"\'])\n    [[(\'text/html\', None), (\'charset\', \'iso-8859-1\')]]\n    >>> split_header_words([r\'Basic realm="\\"foo\\bar\\""\'])\n    [[(\'Basic\', None), (\'realm\', \'"foobar"\')]]\n\n    ', 1, '\\1', None, ',', '^[=\\s;]*', '', 0, "split_header_words bug: '", "', '", "', ")

## co_names:
('isinstance', 'str', 'HEADER_TOKEN_RE', 'search', 'unmatched', 'group', 'HEADER_QUOTED_VALUE_RE', 'HEADER_ESCAPE_RE', 'sub', 'HEADER_VALUE_RE', 'rstrip', 'append', 'lstrip', 'startswith', 're', 'subn')

## bytecode:

   0: RESUME               
   2: LOAD_GLOBAL          NULL + isinstance
  14: LOAD_FAST            header_values
  16: LOAD_GLOBAL          str
  28: PRECALL              
  32: CALL                 
  42: POP_JUMP_FORWARD_IF_FALSE to 48
  44: LOAD_ASSERTION_ERROR 
  46: RAISE_VARARGS        
  48: BUILD_LIST           
  50: STORE_FAST           result
  52: LOAD_FAST            header_values
  54: GET_ITER             
  56: EXTENDED_ARG         
  58: FOR_ITER             to 956
  60: STORE_FAST           text
  62: LOAD_FAST            text
  64: STORE_FAST           orig_text
  66: BUILD_LIST           
  68: STORE_FAST           pairs
  70: LOAD_FAST            text
  72: EXTENDED_ARG         
  74: POP_JUMP_FORWARD_IF_FALSE to 906
  76: LOAD_GLOBAL          HEADER_TOKEN_RE
  88: LOAD_METHOD          search
 110: LOAD_FAST            text
 112: PRECALL              
 116: CALL                 
 126: STORE_FAST           m
 128: LOAD_FAST            m
 130: POP_JUMP_FORWARD_IF_FALSE to 610
 132: LOAD_GLOBAL          NULL + unmatched
 144: LOAD_FAST            m
 146: PRECALL              
 150: CALL                 
 160: STORE_FAST           text
 162: LOAD_FAST            m
 164: LOAD_METHOD          group
 186: LOAD_CONST           1
 188: PRECALL              
 192: CALL                 
 202: STORE_FAST           name
 204: LOAD_GLOBAL          HEADER_QUOTED_VALUE_RE
 216: LOAD_METHOD          search
 238: LOAD_FAST            text
 240: PRECALL              
 244: CALL                 
 254: STORE_FAST           m
 256: LOAD_FAST            m
 258: POP_JUMP_FORWARD_IF_FALSE to 388
 260: LOAD_GLOBAL          NULL + unmatched
 272: LOAD_FAST            m
 274: PRECALL              
 278: CALL                 
 288: STORE_FAST           text
 290: LOAD_FAST            m
 292: LOAD_METHOD          group
 314: LOAD_CONST           1
 316: PRECALL              
 320: CALL                 
 330: STORE_FAST           value
 332: LOAD_GLOBAL          HEADER_ESCAPE_RE
 344: LOAD_METHOD          sub
 366: LOAD_CONST           '\\1'
 368: LOAD_FAST            value
 370: PRECALL              
 374: CALL                 
 384: STORE_FAST           value
 386: JUMP_FORWARD         to 562
 388: LOAD_GLOBAL          HEADER_VALUE_RE
 400: LOAD_METHOD          search
 422: LOAD_FAST            text
 424: PRECALL              
 428: CALL                 
 438: STORE_FAST           m
 440: LOAD_FAST            m
 442: POP_JUMP_FORWARD_IF_FALSE to 558
 444: LOAD_GLOBAL          NULL + unmatched
 456: LOAD_FAST            m
 458: PRECALL              
 462: CALL                 
 472: STORE_FAST           text
 474: LOAD_FAST            m
 476: LOAD_METHOD          group
 498: LOAD_CONST           1
 500: PRECALL              
 504: CALL                 
 514: STORE_FAST           value
 516: LOAD_FAST            value
 518: LOAD_METHOD          rstrip
 540: PRECALL              
 544: CALL                 
 554: STORE_FAST           value
 556: JUMP_FORWARD         to 562
 558: LOAD_CONST           None
 560: STORE_FAST           value
 562: LOAD_FAST            pairs
 564: LOAD_METHOD          append
 586: LOAD_FAST            name
 588: LOAD_FAST            value
 590: BUILD_TUPLE          
 592: PRECALL              
 596: CALL                 
 606: POP_TOP              
 608: JUMP_FORWARD         to 900
 610: LOAD_FAST            text
 612: LOAD_METHOD          lstrip
 634: PRECALL              
 638: CALL                 
 648: LOAD_METHOD          startswith
 670: LOAD_CONST           ','
 672: PRECALL              
 676: CALL                 
 686: POP_JUMP_FORWARD_IF_FALSE to 796
 688: LOAD_FAST            text
 690: LOAD_METHOD          lstrip
 712: PRECALL              
 716: CALL                 
 726: LOAD_CONST           1
 728: LOAD_CONST           None
 730: BUILD_SLICE          
 732: BINARY_SUBSCR        
 742: STORE_FAST           text
 744: LOAD_FAST            pairs
 746: POP_JUMP_FORWARD_IF_FALSE to 790
 748: LOAD_FAST            result
 750: LOAD_METHOD          append
 772: LOAD_FAST            pairs
 774: PRECALL              
 778: CALL                 
 788: POP_TOP              
 790: BUILD_LIST           
 792: STORE_FAST           pairs
 794: JUMP_FORWARD         to 900
 796: LOAD_GLOBAL          NULL + re
 808: LOAD_ATTR            subn
 818: LOAD_CONST           '^[=\\s;]*'
 820: LOAD_CONST           ''
 822: LOAD_FAST            text
 824: PRECALL              
 828: CALL                 
 838: UNPACK_SEQUENCE      
 842: STORE_FAST           non_junk
 844: STORE_FAST           nr_junk_chars
 846: LOAD_FAST            nr_junk_chars
 848: LOAD_CONST           0
 850: COMPARE_OP           >
 856: POP_JUMP_FORWARD_IF_TRUE to 896
 858: LOAD_ASSERTION_ERROR 
 860: LOAD_CONST           "split_header_words bug: '"
 862: LOAD_FAST            orig_text
 864: FORMAT_VALUE         str
 866: LOAD_CONST           "', '"
 868: LOAD_FAST            text
 870: FORMAT_VALUE         str
 872: LOAD_CONST           "', "
 874: LOAD_FAST            pairs
 876: FORMAT_VALUE         str
 878: BUILD_STRING         
 880: PRECALL              
 884: CALL                 
 894: RAISE_VARARGS        
 896: LOAD_FAST            non_junk
 898: STORE_FAST           text
 900: LOAD_FAST            text
 902: EXTENDED_ARG         
 904: POP_JUMP_BACKWARD_IF_TRUE to 76
 906: LOAD_FAST            pairs
 908: POP_JUMP_FORWARD_IF_FALSE to 952
 910: LOAD_FAST            result
 912: LOAD_METHOD          append
 934: LOAD_FAST            pairs
 936: PRECALL              
 940: CALL                 
 950: POP_TOP              
 952: EXTENDED_ARG         
 954: JUMP_BACKWARD        to 56
 956: LOAD_FAST            result
 958: RETURN_VALUE         
