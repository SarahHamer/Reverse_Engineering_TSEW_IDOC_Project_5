# Disassembly for statistics.median_grouped
# From module file: statistics

## co_consts:
('Estimates the median for numeric data binned around the midpoints\n    of consecutive, fixed-width intervals.\n\n    The *data* can be any iterable of numeric data with each value being\n    exactly the midpoint of a bin.  At least one value must be present.\n\n    The *interval* is width of each bin.\n\n    For example, demographic information may have been summarized into\n    consecutive ten-year age groups with each group being represented\n    by the 5-year midpoints of the intervals:\n\n        >>> demographics = Counter({\n        ...    25: 172,   # 20 to 30 years old\n        ...    35: 484,   # 30 to 40 years old\n        ...    45: 387,   # 40 to 50 years old\n        ...    55:  22,   # 50 to 60 years old\n        ...    65:   6,   # 60 to 70 years old\n        ... })\n\n    The 50th percentile (median) is the 536th person out of the 1071\n    member cohort.  That person is in the 30 to 40 year old age group.\n\n    The regular median() function would assume that everyone in the\n    tricenarian age group was exactly 35 years old.  A more tenable\n    assumption is that the 484 members of that age group are evenly\n    distributed between 30 and 40.  For that, we use median_grouped().\n\n        >>> data = list(demographics.elements())\n        >>> median(data)\n        35\n        >>> round(median_grouped(data, interval=10), 1)\n        37.5\n\n    The caller is responsible for making sure the data points are separated\n    by exact multiples of *interval*.  This is essential for getting a\n    correct result.  The function does not check this precondition.\n\n    Inputs may be any numeric type that can be coerced to a float during\n    the interpolation step.\n\n    ', 'no median for empty data', 2, ('lo',), 'Value cannot be converted to a float', 2.0)

## co_names:
('sorted', 'len', 'StatisticsError', 'bisect_left', 'bisect_right', 'float', 'ValueError', 'TypeError')

## bytecode:

   0: RESUME               
   2: LOAD_GLOBAL          NULL + sorted
  14: LOAD_FAST            data
  16: PRECALL              
  20: CALL                 
  30: STORE_FAST           data
  32: LOAD_GLOBAL          NULL + len
  44: LOAD_FAST            data
  46: PRECALL              
  50: CALL                 
  60: STORE_FAST           n
  62: LOAD_FAST            n
  64: POP_JUMP_FORWARD_IF_TRUE to 96
  66: LOAD_GLOBAL          NULL + StatisticsError
  78: LOAD_CONST           'no median for empty data'
  80: PRECALL              
  84: CALL                 
  94: RAISE_VARARGS        
  96: LOAD_FAST            data
  98: LOAD_FAST            n
 100: LOAD_CONST           2
 102: BINARY_OP            //
 106: BINARY_SUBSCR        
 116: STORE_FAST           x
 118: LOAD_GLOBAL          NULL + bisect_left
 130: LOAD_FAST            data
 132: LOAD_FAST            x
 134: PRECALL              
 138: CALL                 
 148: STORE_FAST           i
 150: LOAD_GLOBAL          NULL + bisect_right
 162: LOAD_FAST            data
 164: LOAD_FAST            x
 166: LOAD_FAST            i
 168: KW_NAMES             
 170: PRECALL              
 174: CALL                 
 184: STORE_FAST           j
 186: NOP                  
 188: LOAD_GLOBAL          NULL + float
 200: LOAD_FAST            interval
 202: PRECALL              
 206: CALL                 
 216: STORE_FAST           interval
 218: LOAD_GLOBAL          NULL + float
 230: LOAD_FAST            x
 232: PRECALL              
 236: CALL                 
 246: STORE_FAST           x
 248: JUMP_FORWARD         to 308
 250: PUSH_EXC_INFO        
 252: LOAD_GLOBAL          ValueError
 264: CHECK_EXC_MATCH      
 266: POP_JUMP_FORWARD_IF_FALSE to 300
 268: POP_TOP              
 270: LOAD_GLOBAL          NULL + TypeError
 282: LOAD_CONST           'Value cannot be converted to a float'
 284: PRECALL              
 288: CALL                 
 298: RAISE_VARARGS        
 300: RERAISE              
 302: COPY                 
 304: POP_EXCEPT           
 306: RERAISE              
 308: LOAD_FAST            x
 310: LOAD_FAST            interval
 312: LOAD_CONST           2.0
 314: BINARY_OP            /
 318: BINARY_OP            -
 322: STORE_FAST           L
 324: LOAD_FAST            i
 326: STORE_FAST           cf
 328: LOAD_FAST            j
 330: LOAD_FAST            i
 332: BINARY_OP            -
 336: STORE_FAST           f
 338: LOAD_FAST            L
 340: LOAD_FAST            interval
 342: LOAD_FAST            n
 344: LOAD_CONST           2
 346: BINARY_OP            /
 350: LOAD_FAST            cf
 352: BINARY_OP            -
 356: BINARY_OP            *
 360: LOAD_FAST            f
 362: BINARY_OP            /
 366: BINARY_OP            +
 370: RETURN_VALUE         
