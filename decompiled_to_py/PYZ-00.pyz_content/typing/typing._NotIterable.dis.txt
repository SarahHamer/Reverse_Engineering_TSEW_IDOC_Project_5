# Disassembly for typing._NotIterable
# From module file: typing

## co_consts:
('_NotIterable', 'Mixin to prevent iteration, without being compatible with Iterable.\n\n    That is, we could do::\n\n        def __iter__(self): raise TypeError()\n\n    But this would make users of this mixin duck type-compatible with\n    collections.abc.Iterable - isinstance(foo, Iterable) would be True.\n\n    Luckily, we can instead prevent iteration by setting __iter__ to None, which\n    is treated specially.\n    ', (), None)

## co_names:
('__name__', '__module__', '__qualname__', '__doc__', '__slots__', '__iter__')

## bytecode:

   0: RESUME               
   2: LOAD_NAME            __name__
   4: STORE_NAME           __module__
   6: LOAD_CONST           '_NotIterable'
   8: STORE_NAME           __qualname__
  10: LOAD_CONST           'Mixin to prevent iteration, without being compatible with Iterable.\n\n    That is, we could do::\n\n        def __iter__(self): raise TypeError()\n\n    But this would make users of this mixin duck type-compatible with\n    collections.abc.Iterable - isinstance(foo, Iterable) would be True.\n\n    Luckily, we can instead prevent iteration by setting __iter__ to None, which\n    is treated specially.\n    '
  12: STORE_NAME           __doc__
  14: LOAD_CONST           ()
  16: STORE_NAME           __slots__
  18: LOAD_CONST           None
  20: STORE_NAME           __iter__
  22: LOAD_CONST           None
  24: RETURN_VALUE         
