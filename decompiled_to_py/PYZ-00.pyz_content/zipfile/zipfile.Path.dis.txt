# Disassembly for zipfile.Path
# From module file: zipfile

## co_consts:
('Path', "\n    A pathlib-compatible interface for zip files.\n\n    Consider a zip file with this structure::\n\n        .\n        ├── a.txt\n        └── b\n            ├── c.txt\n            └── d\n                └── e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> root = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = root.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text()\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile. Note these attributes are not\n    valid and will raise a ``ValueError`` if the zipfile\n    has no filename.\n\n    >>> root.name\n    'abcde.zip'\n    >>> str(root.filename).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip'\n    >>> str(root.parent)\n    'mem'\n    ", '{self.__class__.__name__}({self.root.filename!r}, {self.at!r})', '', <code object __init__ at 0x0000024069CE4690, file "zipfile.py", line 2390>, 'r', None, ('pwd',), <code object open at 0x0000024068DF6F90, file "zipfile.py", line 2403>, <code object _base at 0x0000024069CE47A0, file "zipfile.py", line 2423>, <code object name at 0x0000024069CF6790, file "zipfile.py", line 2426>, <code object suffix at 0x0000024069CF6880, file "zipfile.py", line 2430>, <code object suffixes at 0x0000024069CF6970, file "zipfile.py", line 2434>, <code object stem at 0x0000024069CF6A60, file "zipfile.py", line 2438>, <code object filename at 0x00000240693D2C20, file "zipfile.py", line 2442>, <code object read_text at 0x00000240691F82F0, file "zipfile.py", line 2446>, <code object read_bytes at 0x00000240693AAFB0, file "zipfile.py", line 2451>, <code object _is_child at 0x000002406922D290, file "zipfile.py", line 2455>, <code object _next at 0x0000024069CF6B50, file "zipfile.py", line 2458>, <code object is_dir at 0x0000024069CDD430, file "zipfile.py", line 2461>, <code object is_file at 0x0000024069CE48B0, file "zipfile.py", line 2464>, <code object exists at 0x0000024069CDD530, file "zipfile.py", line 2467>, <code object iterdir at 0x000002406942DDE0, file "zipfile.py", line 2470>, <code object __str__ at 0x0000024069CE49C0, file "zipfile.py", line 2476>, <code object __repr__ at 0x0000024069CF6D30, file "zipfile.py", line 2479>, <code object joinpath at 0x000002406922DA70, file "zipfile.py", line 2482>, <code object parent at 0x000002406949C5F0, file "zipfile.py", line 2488>, ('',), ('r',))

## co_names:
('__name__', '__module__', '__qualname__', '__doc__', '_Path__repr', '__init__', 'open', '_base', 'property', 'name', 'suffix', 'suffixes', 'stem', 'filename', 'read_text', 'read_bytes', '_is_child', '_next', 'is_dir', 'is_file', 'exists', 'iterdir', '__str__', '__repr__', 'joinpath', '__truediv__', 'parent')

## bytecode:

   0: RESUME               
   2: LOAD_NAME            __name__
   4: STORE_NAME           __module__
   6: LOAD_CONST           'Path'
   8: STORE_NAME           __qualname__
  10: LOAD_CONST           "\n    A pathlib-compatible interface for zip files.\n\n    Consider a zip file with this structure::\n\n        .\n        ├── a.txt\n        └── b\n            ├── c.txt\n            └── d\n                └── e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> root = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = root.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text()\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile. Note these attributes are not\n    valid and will raise a ``ValueError`` if the zipfile\n    has no filename.\n\n    >>> root.name\n    'abcde.zip'\n    >>> str(root.filename).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip'\n    >>> str(root.parent)\n    'mem'\n    "
  12: STORE_NAME           __doc__
  14: LOAD_CONST           '{self.__class__.__name__}({self.root.filename!r}, {self.at!r})'
  16: STORE_NAME           _Path__repr
  18: LOAD_CONST           ('',)
  20: LOAD_CONST           <code object __init__ at 0x0000024069CE4690, file "zipfile.py", line 2390>
  22: MAKE_FUNCTION        defaults
  24: STORE_NAME           __init__
  26: LOAD_CONST           ('r',)
  28: LOAD_CONST           None
  30: LOAD_CONST           ('pwd',)
  32: BUILD_CONST_KEY_MAP  
  34: LOAD_CONST           <code object open at 0x0000024068DF6F90, file "zipfile.py", line 2403>
  36: MAKE_FUNCTION        defaults, kwdefaults
  38: STORE_NAME           open
  40: LOAD_CONST           <code object _base at 0x0000024069CE47A0, file "zipfile.py", line 2423>
  42: MAKE_FUNCTION        
  44: STORE_NAME           _base
  46: LOAD_NAME            property
  48: LOAD_CONST           <code object name at 0x0000024069CF6790, file "zipfile.py", line 2426>
  50: MAKE_FUNCTION        
  52: PRECALL              
  56: CALL                 
  66: STORE_NAME           name
  68: LOAD_NAME            property
  70: LOAD_CONST           <code object suffix at 0x0000024069CF6880, file "zipfile.py", line 2430>
  72: MAKE_FUNCTION        
  74: PRECALL              
  78: CALL                 
  88: STORE_NAME           suffix
  90: LOAD_NAME            property
  92: LOAD_CONST           <code object suffixes at 0x0000024069CF6970, file "zipfile.py", line 2434>
  94: MAKE_FUNCTION        
  96: PRECALL              
 100: CALL                 
 110: STORE_NAME           suffixes
 112: LOAD_NAME            property
 114: LOAD_CONST           <code object stem at 0x0000024069CF6A60, file "zipfile.py", line 2438>
 116: MAKE_FUNCTION        
 118: PRECALL              
 122: CALL                 
 132: STORE_NAME           stem
 134: LOAD_NAME            property
 136: LOAD_CONST           <code object filename at 0x00000240693D2C20, file "zipfile.py", line 2442>
 138: MAKE_FUNCTION        
 140: PRECALL              
 144: CALL                 
 154: STORE_NAME           filename
 156: LOAD_CONST           <code object read_text at 0x00000240691F82F0, file "zipfile.py", line 2446>
 158: MAKE_FUNCTION        
 160: STORE_NAME           read_text
 162: LOAD_CONST           <code object read_bytes at 0x00000240693AAFB0, file "zipfile.py", line 2451>
 164: MAKE_FUNCTION        
 166: STORE_NAME           read_bytes
 168: LOAD_CONST           <code object _is_child at 0x000002406922D290, file "zipfile.py", line 2455>
 170: MAKE_FUNCTION        
 172: STORE_NAME           _is_child
 174: LOAD_CONST           <code object _next at 0x0000024069CF6B50, file "zipfile.py", line 2458>
 176: MAKE_FUNCTION        
 178: STORE_NAME           _next
 180: LOAD_CONST           <code object is_dir at 0x0000024069CDD430, file "zipfile.py", line 2461>
 182: MAKE_FUNCTION        
 184: STORE_NAME           is_dir
 186: LOAD_CONST           <code object is_file at 0x0000024069CE48B0, file "zipfile.py", line 2464>
 188: MAKE_FUNCTION        
 190: STORE_NAME           is_file
 192: LOAD_CONST           <code object exists at 0x0000024069CDD530, file "zipfile.py", line 2467>
 194: MAKE_FUNCTION        
 196: STORE_NAME           exists
 198: LOAD_CONST           <code object iterdir at 0x000002406942DDE0, file "zipfile.py", line 2470>
 200: MAKE_FUNCTION        
 202: STORE_NAME           iterdir
 204: LOAD_CONST           <code object __str__ at 0x0000024069CE49C0, file "zipfile.py", line 2476>
 206: MAKE_FUNCTION        
 208: STORE_NAME           __str__
 210: LOAD_CONST           <code object __repr__ at 0x0000024069CF6D30, file "zipfile.py", line 2479>
 212: MAKE_FUNCTION        
 214: STORE_NAME           __repr__
 216: LOAD_CONST           <code object joinpath at 0x000002406922DA70, file "zipfile.py", line 2482>
 218: MAKE_FUNCTION        
 220: STORE_NAME           joinpath
 222: LOAD_NAME            joinpath
 224: STORE_NAME           __truediv__
 226: LOAD_NAME            property
 228: LOAD_CONST           <code object parent at 0x000002406949C5F0, file "zipfile.py", line 2488>
 230: MAKE_FUNCTION        
 232: PRECALL              
 236: CALL                 
 246: STORE_NAME           parent
 248: LOAD_CONST           None
 250: RETURN_VALUE         
