# Disassembly for typing.ParamSpec
# From module file: typing

## co_consts:
('ParamSpec', "Parameter specification variable.\n\n    Usage::\n\n       P = ParamSpec('P')\n\n    Parameter specification variables exist primarily for the benefit of static\n    type checkers.  They are used to forward the parameter types of one\n    callable to another callable, a pattern commonly found in higher order\n    functions and decorators.  They are only valid when used in ``Concatenate``,\n    or as the first argument to ``Callable``, or as parameters for user-defined\n    Generics.  See class Generic for more information on generic types.  An\n    example for annotating a decorator::\n\n       T = TypeVar('T')\n       P = ParamSpec('P')\n\n       def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n           '''A type-safe decorator to add logging to a function.'''\n           def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n               logging.info(f'{f.__name__} was called')\n               return f(*args, **kwargs)\n           return inner\n\n       @add_logging\n       def add_two(x: float, y: float) -> float:\n           '''Add two numbers together.'''\n           return x + y\n\n    Parameter specification variables can be introspected. e.g.:\n\n       P.__name__ == 'P'\n\n    Note that only parameter specification variables defined in global scope can\n    be pickled.\n    ", <code object args at 0x0000024069465D10, file "typing.py", line 1208>, <code object kwargs at 0x00000240694656F0, file "typing.py", line 1212>, None, False, ('bound', 'covariant', 'contravariant'), <code object __init__ at 0x00000240691F23A0, file "typing.py", line 1216>, <code object __typing_subst__ at 0x000002406949D730, file "typing.py", line 1223>, <code object __typing_prepare_subst__ at 0x0000024068D6E320, file "typing.py", line 1231>)

## co_names:
('__name__', '__module__', '__qualname__', '__doc__', 'property', 'args', 'kwargs', '__init__', '__typing_subst__', '__typing_prepare_subst__', '__classcell__')

## bytecode:

   0: MAKE_CELL            __class__
   2: RESUME               
   4: LOAD_NAME            __name__
   6: STORE_NAME           __module__
   8: LOAD_CONST           'ParamSpec'
  10: STORE_NAME           __qualname__
  12: LOAD_CONST           "Parameter specification variable.\n\n    Usage::\n\n       P = ParamSpec('P')\n\n    Parameter specification variables exist primarily for the benefit of static\n    type checkers.  They are used to forward the parameter types of one\n    callable to another callable, a pattern commonly found in higher order\n    functions and decorators.  They are only valid when used in ``Concatenate``,\n    or as the first argument to ``Callable``, or as parameters for user-defined\n    Generics.  See class Generic for more information on generic types.  An\n    example for annotating a decorator::\n\n       T = TypeVar('T')\n       P = ParamSpec('P')\n\n       def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n           '''A type-safe decorator to add logging to a function.'''\n           def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n               logging.info(f'{f.__name__} was called')\n               return f(*args, **kwargs)\n           return inner\n\n       @add_logging\n       def add_two(x: float, y: float) -> float:\n           '''Add two numbers together.'''\n           return x + y\n\n    Parameter specification variables can be introspected. e.g.:\n\n       P.__name__ == 'P'\n\n    Note that only parameter specification variables defined in global scope can\n    be pickled.\n    "
  14: STORE_NAME           __doc__
  16: LOAD_NAME            property
  18: LOAD_CONST           <code object args at 0x0000024069465D10, file "typing.py", line 1208>
  20: MAKE_FUNCTION        
  22: PRECALL              
  26: CALL                 
  36: STORE_NAME           args
  38: LOAD_NAME            property
  40: LOAD_CONST           <code object kwargs at 0x00000240694656F0, file "typing.py", line 1212>
  42: MAKE_FUNCTION        
  44: PRECALL              
  48: CALL                 
  58: STORE_NAME           kwargs
  60: LOAD_CONST           None
  62: LOAD_CONST           False
  64: LOAD_CONST           False
  66: LOAD_CONST           ('bound', 'covariant', 'contravariant')
  68: BUILD_CONST_KEY_MAP  
  70: LOAD_CLOSURE         __class__
  72: BUILD_TUPLE          
  74: LOAD_CONST           <code object __init__ at 0x00000240691F23A0, file "typing.py", line 1216>
  76: MAKE_FUNCTION        kwdefaults, closure
  78: STORE_NAME           __init__
  80: LOAD_CONST           <code object __typing_subst__ at 0x000002406949D730, file "typing.py", line 1223>
  82: MAKE_FUNCTION        
  84: STORE_NAME           __typing_subst__
  86: LOAD_CONST           <code object __typing_prepare_subst__ at 0x0000024068D6E320, file "typing.py", line 1231>
  88: MAKE_FUNCTION        
  90: STORE_NAME           __typing_prepare_subst__
  92: LOAD_CLOSURE         __class__
  94: COPY                 
  96: STORE_NAME           __classcell__
  98: RETURN_VALUE         
